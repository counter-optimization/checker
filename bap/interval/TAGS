
abstract_memory.ml,3503
open CoreAbstract_memory1,0
module BaseSetMap = structBaseSetMap11,258
  module SS = Set.Make_binable_using_comparator(String)SS13,337
  let bases_of_vars (vars : SS.t) bsm : Region.Set.t =bases_of_vars15,394
module Cell(N : NumericDomain) = structCell31,902
  module T = structT32,942
    type t = { region: Region.t;t33,962
    type t = { region: Region.t;region33,962
               offs: Wrapping_interval.t;offs34,995
               valtype: CellType.t;valtype35,1037
               width: Wrapping_interval.t } [@@deriving sexp_of]width36,1073
    let compare x y =compare38,1139
    let same_address c1 c2 : bool =same_address54,1658
    let same_cell c1 c2 : bool =same_cell58,1785
    let bits_per_byte = Wrapping_interval.of_int 8bits_per_byte62,1897
    let width_in_bits c = c.widthwidth_in_bits64,1953
    let width_in_bytes c =width_in_bytes66,1992
    let width_in_bytes_int (cell : t) : int Or_error.t =width_in_bytes_int70,2105
    let get_intvl : N.t -> Wrapping_interval.t =get_intvl76,2272
    let make ~region ~offs ~width ~valtype : t =make81,2490
    let name (m : t) : string =name101,3348
    let to_string m : string =to_string107,3600
    let pp (m : t) : unit =pp111,3734
    let overlaps cel other : bool =overlaps131,4614
  module Cmp = structCmp152,5339
  module Set = structSet159,5430
    type t = (Cmp.t, comparator_witness) Set.tt161,5509
    let empty : t = Set.empty (module Cmp)empty163,5557
    let empty : t = Set.empty (module Cmp)Cmp163,5557
module BaseSet = Region.SetBaseSet225,7833
module Make(N : NumericDomain)Make227,7862
  module Overlap = structOverlap262,8677
    type offs = WI.t listoffs263,8703
    type t = { cell : C.t ; offsets : offs ; data : N.t }t265,8736
    type t = { cell : C.t ; offsets : offs ; data : N.t }cell265,8736
    type t = { cell : C.t ; offsets : offs ; data : N.t }offsets265,8736
    type t = { cell : C.t ; offsets : offs ; data : N.t }data265,8736
    let of_existing_cell (cell : C.t) (mem : T.t) : t =of_existing_cell267,8795
  let pp {cells; env; bases; globals_read}  =pp369,13416
  let empty : t = { cells = C.Set.empty;empty386,14106
                  let segname = Image.Segment.name seg insegname586,21862
                let res = N.of_word data inres592,22205
  let set_cell_to_top (c : C.t) ?(secret : bool = false) (mem : t) : t =set_cell_to_top597,22414
  let load_of_bil_exp (e : Bil.exp) (idx_res : N.t)load_of_bil_exp764,29578
  let ensure_offs_range_is_ok ~(offs : Wrapping_interval.t)ensure_offs_range_is_ok849,33625
  let get_all_offs ~(offs : Wrapping_interval.t)get_all_offs867,34283
  let set_stack_canary (mem : t) : t =set_stack_canary903,35434
  let store_of_bil_exp (e : Bil.exp) ~(offs : N.t) ~data ~size mstore_of_bil_exp934,36630
          let all_offs = get_all_offs ~offs ~width inall_offs966,38063
  let store_init_ret_ptr (mem : t) : t err =store_init_ret_ptr997,39416
  let havoc_on_call (mem : t) : t =havoc_on_call1023,40443
  let set_rsp (offs : int) (mem : t) : t err =set_rsp1037,40914
  let set_rbp (offs : int) (mem : t) : t err =set_rbp1048,41277
  let merge_images img1 img2 : Image.t option =merge_images1058,41635
  let merge mem1 mem2 : t =merge1067,41842
    let merged_globals_read = Set.union gr1 gr2 inmerged_globals_read1070,42040
  let widen_threshold = 256widen_threshold1081,42427
  let widen_with_step steps n prev next : t =widen_with_step1083,42456

alert.ml,1325
open CoreAlert1,0
type reason = CompSimp | SilentStoresreason4,24
type reason = CompSimp | SilentStoresCompSimp4,24
type reason = CompSimp | SilentStoresSilentStores4,24
let string_of_reason = functionstring_of_reason7,132
module T = structT11,229
  type t = { sub_name : string option; t14,383
  type t = { sub_name : string option; sub_name14,383
             tid : Tid.t;tid15,423
             flags_live : bool option;flags_live16,449
             problematic_operands : int list option;problematic_operands17,488
             left_val : string option;left_val18,541
             right_val : string option;right_val19,580
             reason : reason;reason20,620
             desc : string }desc21,650
module Cmp = structCmp25,739
module Set = structSet30,805
let t_of_reason_and_tid (reason : reason) (tid : Tid.t) : t =t_of_reason_and_tid36,890
let set_flags_live (x : t) : t =set_flags_live47,1112
let set_flags_live (x : t) : t =set_flags_live50,1182
let add_problematic_operands (x : t) (prob_op : int list) : t =add_problematic_operands53,1252
let to_string (x : t) : string =to_string60,1505
  let sub_name_str = match sub_name withsub_name_str70,1696
let print_alert (alert : t) : unit =print_alert100,2617
let print_alerts : Set.t -> unit =print_alerts103,2701

bases_domain.ml,2482
open CoreBases_domain1,0
module KB = Bap_core_theory.KBKB5,36
module MBase = RegionMBase7,68
module Bases = Region.SetBases8,90
type t = Region.Set.tt10,117
module Key = Common.DomainKeyKey12,140
let key : t Key.k = Key.create "bases_domain"key14,171
let get : type a. a Key.k -> (t -> a) option = fun k ->get16,218
let set : type a. a Key.k -> t -> a -> t = fun k other replace ->set21,350
let stack = Bases.singleton MBase.Stackstack26,483
let global = Bases.singleton MBase.Globalglobal28,524
let heap = Bases.singleton MBase.Heapheap30,567
let bot = Bases.emptybot32,606
let top = Bases.of_list [MBase.Global; MBase.Heap; MBase.Stack]top34,629
let make_top _sz _signed = topmake_top36,694
let not_callable_exception fn_name =not_callable_exception38,726
let b1 = Bases.emptyb141,829
let b0 = Bases.emptyb043,851
let order x y =order45,873
let compare = Bases.comparecompare55,1119
let equal = Bases.equalequal57,1148
let join = Bases.unionjoin59,1173
let meet = Bases.intermeet61,1197
let contains x y =contains63,1221
let add = joinadd70,1326
let sub = joinsub72,1342
let mul = joinmul74,1358
let div = joindiv76,1374
let sdiv = joinsdiv78,1390
let umod = joinumod80,1407
let smod = joinsmod82,1424
let lshift = joinlshift84,1441
let rshift = joinrshift86,1460
let arshift = joinarshift88,1479
let logand = joinlogand90,1499
let logor = joinlogor92,1518
let logxor = joinlogxor94,1536
let neg = fun x -> xneg96,1555
let lnot = fun x -> xlnot98,1577
let extract v hi lo = vextract100,1600
let concat = joinconcat102,1625
let booleq x y = Bases.emptybooleq104,1644
let boolneq x y = Bases.emptyboolneq106,1674
let boollt x y = Bases.emptyboollt108,1705
let boolle x y = Bases.emptyboolle110,1735
let boolslt x y = Bases.emptyboolslt112,1765
let boolsle x y = Bases.emptyboolsle114,1796
let could_be_true _ = truecould_be_true116,1827
let could_be_false _ = truecould_be_false118,1855
let unsigned n v = Bases.emptyunsigned120,1884
let signed n v = Bases.emptysigned122,1916
let low n v = Bases.emptylow124,1946
let high n v = Bases.emptyhigh126,1973
let to_string (bases : Bases.t) : string =to_string128,2001
let of_int ?width v = Bases.emptyof_int142,2437
let of_word w = Bases.emptyof_word144,2472
let of_z ?width z = Bases.emptyof_z146,2501
let bitwidth v = not_callable_exception "bitwidth"bitwidth148,2534
let sexp_of_t = Bases.sexp_of_tsexp_of_t150,2586

callees.ml,1279
open CoreCallees1,0
module T = Bap_core_theory.TheoryT7,70
module KB = Bap_knowledge.KnowledgeKB8,104
module Getter(N : NumericDomain) = structGetter21,739
  module E = structE22,781
    type region = Region.tregion23,801
    type regions = Region.Set.tregions24,828
    type valtypes = Common.cell_tvaltypes25,860
  module AI = AbstractInterpreter(N)(Region)(Region.Set)(struct type t = Common.cell_t end)(E)AI29,939
  module AI = AbstractInterpreter(N)(Region)(Region.Set)(struct type t = Common.cell_t end)(E)t29,939
  module WI = Wrapping_intervalWI30,1034
  module SS = Common.SSSS31,1066
  module CG = Graphs.CallgraphCG32,1090
  type rel = Common.CalleeRel.trel36,1153
  type t = rel listt37,1185
  let name = "get-callees"name39,1206
  let get_intvl : N.t -> Wrapping_interval.t =get_intvl41,1234
  let sub_name_of_tid_exn (proj : Project.t) (tid : Tid.t) : string =sub_name_of_tid_exn46,1447
  let get_bb_tid_sub_db (prog : Program.t) : (Tid.t, Tid.t) List.Assoc.t =get_bb_tid_sub_db58,1772
  let get_callee_of_indirect (exp : exp) (jmp_from : jmp term)get_callee_of_indirect80,2509
  let of_jmp_term (j : jmp term) (sub : sub term)of_jmp_term122,4245
  let get_callees sub proj sol : rel list Or_error.t =get_callees163,5583

calling_context.ml,934
open CoreCalling_context1,0
module KB = Bap_knowledge.KnowledgeKB8,87
module T = structT10,124
  type t = Tid.t list [@@deriving compare, bin_io, sexp, hash]t11,142
  let module_name = Some "Calling_context"module_name13,206
  let version = "0.0.0"version15,250
  let to_string (cc : t) : string =to_string17,275
  let pp ppf (cc : t) =pp25,451
module Regular = structRegular38,732
module Edge = structEdge42,787
  type 'a t = T.t * T.t * 'at43,808
  let from_ (e : 'a t) : T.t =from_45,838
  let to_ (e : 'a t) : T.t =to_49,911
type 'a edges = 'a Edge.t listedges54,984
let to_insn_tid (ctxt : t) : Tid.t =to_insn_tid59,1043
let add_callsite (cs : Tid.t) (ctxt : t) : t = List.cons cs ctxtadd_callsite65,1226
let add_node (n : Tid.t) (ctxt : t) : t = List.cons n ctxtadd_node67,1292
let of_tid (t : Tid.t) : t = [t]of_tid69,1352
let of_edge (e : Edge_builder.edge) : bool Edge.t =of_edge71,1386

checker.ml,244
open CoreChecker1,0
module type S = sigS6,54
  type warns = Alert.Set.twarns7,74
  type t = warnst8,101
  type envenv9,118
  val check_elt : Blk.elt -> Live_variables.t -> env -> warnscheck_elt11,130
  val name : stringname12,192

checker_taint.ml,2432
open CoreChecker_taint1,0
module T = Bap_core_theory.TheoryT6,54
module KB = Bap_core_theory.KBKB7,88
module Key = Common.DomainKeyKey8,119
module Analysis = structAnalysis10,150
  type t = Notaint | Taint [@@deriving bin_io, sexp]t11,175
  type t = Notaint | Taint [@@deriving bin_io, sexp]Notaint11,175
  type t = Notaint | Taint [@@deriving bin_io, sexp]Taint11,175
  let key : t Key.k = Key.create "taint"key13,229
  let get : type a. a Key.k -> (t -> a) option = fun k ->get15,271
  let set : type a. a Key.k -> t -> a -> t = fun k other replace ->set20,411
  let bot = Notaintbot25,552
  let top = Tainttop26,572
  let make_top _width _signed = topmake_top27,590
  let b1 = topb129,627
  let b0 = botb030,642
  let order x y =order32,658
  let compare x y : int =compare39,841
  let equal x y =equal47,976
  let is_tainted : t -> bool = functionis_tainted52,1063
  let join x y =join56,1141
  let meet x y =meet62,1246
  let contains x y =contains68,1357
  let binop = joinbinop74,1473
  let add = binopadd75,1492
  let sub = binopsub76,1510
  let mul = binopmul77,1528
  let div = binopdiv78,1546
  let sdiv = binopsdiv79,1564
  let umod = binopumod80,1583
  let smod = binopsmod81,1602
  let lshift = binoplshift82,1621
  let rshift = binoprshift83,1642
  let arshift = binoparshift84,1663
  let logand = binoplogand85,1685
  let logor = binoplogor86,1706
  let logxor = binoplogxor87,1726
  let ident = fun x -> xident89,1748
  let neg = identneg90,1773
  let lnot = identlnot91,1791
  let booleq = binopbooleq93,1811
  let boolneq = binopboolneq94,1832
  let boollt = binopboollt95,1854
  let boolle = binopboolle96,1875
  let boolslt = binopboolslt97,1896
  let boolsle = binopboolsle98,1918
  let could_be_true _ = truecould_be_true100,1941
  let could_be_false _ = truecould_be_false101,1970
  let drop_first x y = ydrop_first103,2001
  let unsigned = drop_firstunsigned104,2026
  let signed = drop_firstsigned105,2054
  let low = drop_firstlow106,2080
  let high = drop_firsthigh107,2103
  let extract exp hi lo = expextract109,2128
  let concat = joinconcat110,2158
  let to_string = functionto_string112,2179
  let of_int ?(width = 64) _ = Notaintof_int115,2256
  let of_word _ = Notaintof_word116,2295
  let of_z ?(width : int = 64) _ = Notaintof_z117,2321
  let bitwidth x = -1bitwidth118,2364

common.ml,12340
open CoreCommon1,0
module T = Bap_core_theory.TheoryT6,58
module KB = Bap_core_theory.KBKB7,92
module SS = structSS9,124
  module T = structT10,143
let package = "uarch-checker"package17,269
let string_powset_dom = KB.Domain.powersetstring_powset_dom19,300
                          (module String)String20,343
  module Cmp = structCmp42,1040
  module Set = structSet49,1129
    let print (s : t) : unit =print52,1203
    let print_hum (s : t) ~(f : Tid.t -> string) : unit =print_hum56,1301
let sub_of_tid_for_prog (p : Program.t) (t : Tid.t) : sub term Or_error.t =sub_of_tid_for_prog62,1456
module AnalysisBlackList = structAnalysisBlackList69,1715
  let blacklisted_func_names : string list = ["interrupt"]blacklisted_func_names70,1749
  let contains_blacklisted_func_name (subname : string) : bool =contains_blacklisted_func_name72,1809
  let sub_is_blacklisted (sub : sub term) : bool =sub_is_blacklisted76,2018
  let sub_is_not_linked (sub : sub term) : bool =sub_is_not_linked79,2121
module Region = structRegion85,2266
  module T = structT86,2289
    type t = Global | Heap | Stack [@@deriving sexp, bin_io, compare]t87,2309
    type t = Global | Heap | Stack [@@deriving sexp, bin_io, compare]Global87,2309
    type t = Global | Heap | Stack [@@deriving sexp, bin_io, compare]Heap87,2309
    type t = Global | Heap | Stack [@@deriving sexp, bin_io, compare]Stack87,2309
    let equal r1 r2 : bool =equal89,2380
    let to_string = functionto_string96,2524
    let pp x =pp101,2629
  module Cmp = structCmp105,2693
  module Set = structSet112,2782
    let from_region (r : T.t) = singleton rfrom_region114,2855
module CellType = structCellType118,2910
  type t = Scalart119,2935
  type t = ScalarScalar119,2935
         | PtrPtr120,2953
         | UnknownUnknown121,2968
         | Undef [@@deriving sexp, bin_io, compare, equal]Undef122,2987
  let join t1 t2 =join124,3047
  let is_scalar : t -> bool = functionis_scalar148,3568
  let is_ptr : t -> bool = functionis_ptr152,3646
  let is_unknown : t -> bool = functionis_unknown156,3718
  let is_undef : t -> bool = functionis_undef160,3798
  let domain_name = "CellType"domain_name164,3874
  let domain = KB.Domain.define domain_namedomain165,3905
type cell_t = CellType.tcell_t172,4061
type (_, _) eq =eq174,4087
  | Eq : ('a, 'a) eqEq175,4104
module type KeyT = sigKeyT178,4134
  type 'a kk179,4157
  val create : string -> 'a kcreate180,4169
  val eq_type : 'a k -> 'b k -> ('a, 'b) eqeq_type181,4199
  val name : 'a k -> stringname182,4243
module DomainKey : KeyT = structDomainKey187,4361
  type _ key = ..key188,4394
  module type K = sigK190,4413
    type tt191,4435
    type _ key += Key : t keykey192,4446
    val name : stringname193,4476
  type 'a k = (module K with type t = 'a)k196,4505
  type 'a k = (module K with type t = 'a)K196,4505
  type 'a k = (module K with type t = 'a)t196,4505
  let name (type a) (elt : a k) : string =name198,4548
    let module A = (val elt : K with type t = a) inelt199,4591
    let module A = (val elt : K with type t = a) int199,4591
  let create (type a) (n : string) : a k =create202,4655
        type t = at204,4724
        type _ key += Key : t keykey205,4743
        let name = nname206,4777
    (module M : K with type t = a)M208,4811
    (module M : K with type t = a)t208,4811
  let eq_type (type a) (type b) (x : a k) (y : b k) : (a, b) eq =eq_type210,4847
    let module A = (val x : K with type t = a) inx211,4913
    let module A = (val x : K with type t = a) int211,4913
    let module B = (val y : K with type t = b) iny212,4963
    let module B = (val y : K with type t = b) int212,4963
let binop_to_string (b : Bil.binop) : string =binop_to_string218,5072
let elt_to_tid (e : Blk.elt) : tid =elt_to_tid240,5545
let jmp_is_return (j : jmp term) : bool =jmp_is_return257,6143
module type NumericDomain = sigNumericDomain265,6444
  type tt266,6476
  val key : t DomainKey.kkey268,6486
  val get : 'a DomainKey.k -> (t -> 'a) optionget269,6512
  val set : 'a DomainKey.k -> t -> 'a -> tset270,6559
  val bot : tbot272,6603
  val top : ttop273,6617
  val make_top : int -> bool -> t make_top274,6631
  val b1 : tb1276,6667
  val b0 : tb0277,6680
  val order : t -> t -> KB.Order.partialorder279,6694
  val compare : t -> t -> intcompare280,6735
  val equal : t -> t -> boolequal281,6765
  val join : t -> t -> tjoin282,6794
  val meet : t -> t -> tmeet283,6819
  val contains : t -> t -> bool (* Useful for checkers *)contains284,6844
  val add : t -> t -> tadd287,6924
  val sub : t -> t -> tsub288,6948
  val mul : t -> t -> tmul289,6972
  val div : t -> t -> tdiv290,6996
  val sdiv : t -> t -> tsdiv291,7020
  val umod : t -> t -> tumod292,7045
  val smod : t -> t -> tsmod293,7070
  val lshift : t -> t -> tlshift294,7095
  val rshift : t -> t -> trshift295,7122
  val arshift : t -> t -> tarshift296,7149
  val logand : t -> t -> tlogand297,7177
  val logor : t -> t -> tlogor298,7204
  val logxor : t -> t -> tlogxor299,7230
  val neg : t -> tneg301,7258
  val lnot : t -> tlnot302,7277
  val extract : t -> int -> int -> textract304,7298
  val concat : t -> t -> tconcat305,7335
  val booleq : t -> t -> tbooleq307,7365
  val boolneq : t -> t -> tboolneq308,7392
  val boollt : t -> t -> tboollt309,7420
  val boolle : t -> t -> tboolle310,7447
  val boolslt : t -> t -> tboolslt311,7474
  val boolsle : t -> t -> tboolsle312,7502
  val could_be_true : t -> boolcould_be_true313,7530
  val could_be_false : t -> boolcould_be_false314,7562
  val unsigned : int -> t -> tunsigned316,7596
  val signed : int -> t -> tsigned317,7627
  val low : int -> t -> tlow318,7656
  val high : int -> t -> thigh319,7682
  val to_string : t -> stringto_string321,7710
  val of_int : ?width:int -> int -> tof_int322,7740
  val of_word : word -> tof_word323,7778
  val of_z : ?width:int -> Z.t -> tof_z324,7804
  val bitwidth : t -> intbitwidth325,7840
  val sexp_of_t : t -> Sexp.tsexp_of_t326,7866
module type MemoryT =MemoryT347,8426
    type tt349,8454
    type vv351,8470
    type regionsregions353,8486
    type regionregion355,8508
    type valtypesvaltypes357,8529
    type 'a err = ('a, Error.t) Result.terr359,8548
    val empty : tempty361,8590
    val lookup : string -> t -> vlookup363,8613
    val set : string -> v -> t -> tset365,8652
    val unset : string -> t -> tunset367,8689
    val equal : t -> t -> boolequal369,8727
    val set_rsp : int -> t -> t errset_rsp371,8763
    val set_rbp : int -> t -> t errset_rbp373,8804
    val set_img : t -> Image.t -> tset_img375,8845
    val set_stack_canary : t -> tset_stack_canary377,8882
    val holds_ptr : string -> t -> boolholds_ptr379,8921
    val setptr : name:string -> regions:regions -> offs:v -> width:v -> t -> tsetptr381,8966
    val unptr : name:string -> t -> tunptr383,9050
    val load_of_bil_exp : Bil.exp -> v -> Size.t -> t -> (v * t) errload_of_bil_exp387,9158
    val store_of_bil_exp : Bil.exp -> offs:v -> data:v -> size:Size.t -> t -> t errstore_of_bil_exp389,9232
    val havoc_on_call : t -> thavoc_on_call391,9317
    val merge : t -> t -> tmerge393,9349
    val widen_threshold : intwiden_threshold395,9382
    val widen_with_step : int -> 'a -> t -> t -> twiden_with_step397,9417
    val pp : t -> unitpp399,9473
module NumericEnv(ValueDom : NumericDomain)NumericEnv402,9503
  let widen_threshold = 10widen_threshold475,11292
  let widen_with_step steps n prev_state new_state : t =widen_with_step477,11322
  let pp (env : t) : unit =pp496,12207
module AbstractInterpreter(N: NumericDomain)AbstractInterpreter508,12576
         (Rt : sig type t end)t510,12651
         (Vt : sig type t end)t511,12682
         (Env : MemoryT with type v := N.tv512,12713
                         and type region := R.tregion513,12756
                         and type regions := Rt.tregions514,12804
                         and type valtypes := Vt.t) = structvaltypes515,12854
  module E = EnvE516,12915
  module StringSet = Set.Make_binable_using_comparator(String)StringSet517,12932
  module ST = structST519,12996
  let denote_binop (op : binop) : N.t -> N.t -> N.t =denote_binop525,13130
  let denote_cast (c : cast) : int -> N.t -> N.t =denote_cast547,13701
  let denote_unop (op : unop) : N.t -> N.t =denote_unop554,13880
  let rec denote_exp (e : Bil.exp) : N.t ST.t =denote_exp559,13991
  let denote_def (d : def term) : unit ST.t =denote_def682,18934
  let denote_phi (p : phi term) : unit ST.t =denote_phi696,19378
  let denote_jmp (j : jmp term) : unit ST.t =denote_jmp703,19607
  let denote_elt (e : Blk.elt) (st : E.t) : E.t =denote_elt710,19775
         let () = Format.printf "Denoting tid %a\n%!" Tid.pp (Term.tid j) in()718,20049
         let () = Format.printf "Denoting tid %a\n%!" Tid.pp (Term.tid p) in()721,20167
module DomainProduct(X : NumericDomain)(Y : NumericDomain)DomainProduct729,20397
  type t = X.t * Y.tt731,20488
  let key : t DomainKey.k =key733,20510
  let get k =get739,20690
  let set key (x, y) newval =set746,20892
  let first (prod : t) : X.t =first749,20970
  let second (prod : t) : Y.t =second753,21038
  let bot = X.bot, Y.botbot757,21109
  let top = X.top, Y.toptop758,21134
  let make_top width signed = X.make_top width signed, Y.make_top width signedmake_top759,21159
  let b1 = X.b1, Y.b1b1761,21239
  let b0 = X.b0, Y.b0b0762,21261
  let order (x, y) (x', y') =order764,21286
  let compare x y : int =compare772,21455
  let equal f s =equal780,21590
  let join (x, y) (x', y') = X.join x x', Y.join y y'join785,21677
  let meet (x, y) (x', y') = X.meet x x', Y.meet y y'meet786,21731
  let contains (x, y) (x', y') = X.contains x x' || Y.contains y y'contains789,21858
  let binop xf yf =binop791,21927
  let add = binop X.add Y.addadd794,22022
  let sub = binop X.sub Y.subsub795,22052
  let mul = binop X.mul Y.mulmul796,22082
  let div = binop X.div Y.divdiv797,22112
  let sdiv = binop X.sdiv Y.sdivsdiv798,22142
  let umod = binop X.umod Y.umodumod799,22175
  let smod = binop X.smod Y.smodsmod800,22208
  let lshift = binop X.lshift Y.lshiftlshift801,22241
  let rshift = binop X.rshift Y.rshiftrshift802,22280
  let arshift = binop X.arshift Y.arshiftarshift803,22319
  let logand = binop X.logand Y.logandlogand804,22361
  let logor = binop X.logor Y.logorlogor805,22400
  let logxor = binop X.logxor Y.logxorlogxor806,22436
  let neg (x, y) = X.neg x, Y.neg yneg808,22476
  let lnot (x, y) = X.lnot x, Y.lnot ylnot809,22512
  let bincomp xf yf =bincomp812,22624
  let booleq = bincomp X.booleq Y.booleqbooleq815,22693
  let boolneq = bincomp X.boolneq Y.boolneqboolneq816,22734
  let boollt = bincomp X.boollt Y.boolltboollt817,22778
  let boolle = bincomp X.boolle Y.boolleboolle818,22819
  let boolslt = bincomp X.boolslt Y.boolsltboolslt819,22860
  let boolsle = bincomp X.boolsle Y.boolsleboolsle820,22904
  let could_be_true (x, y) = X.could_be_true x || Y.could_be_true ycould_be_true824,23073
  let could_be_false (x, y) = X.could_be_false x || Y.could_be_false ycould_be_false826,23142
  let cast_or_extract xf yf = fun n (x, y) -> xf n x, yf n ycast_or_extract828,23214
  let unsigned = cast_or_extract X.unsigned Y.unsignedunsigned829,23275
  let signed = cast_or_extract X.signed Y.signedsigned830,23330
  let low = cast_or_extract X.low Y.low low831,23379
  let high = cast_or_extract X.high Y.highhigh832,23420
  let extract (x, y) hi lo = X.extract x hi lo, Y.extract y hi loextract834,23464
  let concat (x, y) (x', y') = X.concat x x', Y.concat y y'concat835,23530
  let to_string (x, y) = Format.sprintf "(%s, %s)" (X.to_string x) (Y.to_string y)to_string837,23591
  let of_int ?(width = 64) i = X.of_int ~width i, Y.of_int ~width iof_int838,23674
  let of_word w = X.of_word w, Y.of_word wof_word839,23742
  let of_z ?(width = 64) z = X.of_z ~width z, Y.of_z ~width zof_z840,23785
  let sexp_of_t (x, y) = Sexp.List [ X.sexp_of_t x; Y.sexp_of_t y ]sexp_of_t841,23847
  let bitwidth (x, y) =bitwidth842,23915

comp_simp.ml,2103
open CoreComp_simp1,0
module T = Bap_core_theory.TheoryT7,70
module KB = Bap_core_theory.KBKB8,104
module Checker(N : NumericDomain) = structChecker10,136
  module E = structE11,179
    type region = Abstract_memory.Region.tregion12,199
    type regions = Abstract_memory.Region.Set.tregions13,242
    type valtypes = Common.cell_tvaltypes14,290
  module AI = AbstractInterpreter(N)(Abstract_memory.Region)(Abstract_memory.Region.Set)(struct AI17,366
  module AI = AbstractInterpreter(N)(Abstract_memory.Region)(Abstract_memory.Region.Set)(struct t17,366
  module I = Wrapping_intervalI18,493
  module SS = Common.SSSS19,524
  type warns = Alert.Set.twarns21,549
  type t = warnst22,576
  let name = "comp-simp"name24,594
  module State = structState26,620
    type t = { warns: warns;t27,644
    type t = { warns: warns;warns27,644
               env: E.t;env28,673
               tid : Tid.t;tid29,698
               liveness : Live_variables.t } liveness30,726
    let init in_state tid liveness =init32,773
  module ST = structST39,923
  let get_intvl : N.t -> Wrapping_interval.t =get_intvl45,1065
  let dont_care_vars = ["ZF"; "OF"; "CF"; "AF"; "PF"; "SF"]dont_care_vars50,1259
  let empty : warns = Alert.Set.emptyempty54,1360
  let join : warns -> warns -> warns = Alert.Set.unionjoin55,1398
  let could_be_special (special_for_bw : I.t -> I.t) (to_check : I.t) : bool =could_be_special57,1454
      let special = special_for_bw to_check inspecial61,1587
  let check_binop_operandscheck_binop_operands64,1669
    let left_specials = fst specials inleft_specials70,1839
  let specials_of_binop (op : binop) : (I.t -> I.t) list * (I.t -> I.t) list =specials_of_binop119,3677
    let one i = I.of_int ~width:(I.bitwidth i) 1 inone120,3756
  let check_binop (op : binop) : N.t -> N.t -> unit ST.t =check_binop150,4694
  let rec check_exp (e : Bil.exp) : N.t ST.t =check_exp154,4843
  let check_def (d : def term)check_def218,7028
  let check_elt (e : Blk.elt) (live : Live_variables.t) (env : E.t) : warns =check_elt233,7459

data_section.ml,27
open CoreData_section1,0

domain_key.ml,1422
open CoreDomain_key1,0
module KB = Bap_core_theory.KBKB4,23
type (_, _) eq =eq6,55
  | Eq : ('a, 'a) eqEq7,72
module type KeyT = sigKeyT10,102
  type 'a kk11,125
  val create : string -> 'a kcreate12,137
  val eq_type : 'a k -> 'b k -> ('a, 'b) eqeq_type13,167
  val name : 'a k -> stringname14,211
module DomainKey : KeyT = structDomainKey19,329
  type _ key = ..key20,362
  module type K = sigK22,381
    type tt23,403
    type _ key += Key : t keykey24,414
    val name : stringname25,444
  type 'a k = (module K with type t = 'a)k28,473
  type 'a k = (module K with type t = 'a)K28,473
  type 'a k = (module K with type t = 'a)t28,473
  let name (type a) (elt : a k) : string =name30,516
    let module A = (val elt : K with type t = a) inelt31,559
    let module A = (val elt : K with type t = a) int31,559
  let create (type a) (n : string) : a k =create34,623
        type t = at36,692
        type _ key += Key : t keykey37,711
        let name = nname38,745
    (module M : K with type t = a)M40,779
    (module M : K with type t = a)t40,779
  let eq_type (type a) (type b) (x : a k) (y : b k) : (a, b) eq =eq_type42,815
    let module A = (val x : K with type t = a) inx43,881
    let module A = (val x : K with type t = a) int43,881
    let module B = (val y : K with type t = b) iny44,931
    let module B = (val y : K with type t = b) int44,931

driver.ml,1612
open CoreDriver1,0
module T = Bap_core_theory.TheoryT7,75
module KB = Bap_knowledge.KnowledgeKB8,109
module Cfg = Bap.Std.Graphs.CfgCfg10,146
module IrCfg = Bap.Std.Graphs.IrIrCfg11,178
module CR = Common.CalleeRelCR12,211
module CRS = CR.SetCRS13,240
type check_sub_result = { callees : CRS.t;check_sub_result15,261
type check_sub_result = { callees : CRS.t;callees15,261
                          alerts : Alert.Set.t }alerts16,304
type checker_alerts = Alert.Set.tchecker_alerts18,354
module SubSet = structSubSet20,389
let print_iml iml : unit =print_iml24,466
let print_sol sol : unit =print_sol30,618
let insns_of_node n = Blk.elts @@ Graphs.Ir.Node.label ninsns_of_node36,791
let first_insn_of_blk b =first_insn_of_blk37,848
let get_ret_insn_tid sub_nodes =get_ret_insn_tid43,1015
let sub_of_tid_exn tid proj : sub Term.t =sub_of_tid_exn60,1639
let last_insn_of_sub sub : Blk.elt =last_insn_of_sub72,1967
  let rev_nodes = Graphlib.postorder_traverse (module Graphs.Ir) irg inGraphs74,2034
  let last_node_insns = insns_of_node last_node inlast_node_insns84,2374
let should_skip_analysis (edges : Edge_builder.edges)should_skip_analysis101,3172
let run_analyses sub img proj ~(is_toplevel : bool) : check_sub_result =run_analyses138,4482
     let edges = List.map edges ~f:(Calling_context.of_edge) inedges159,5164
     let cfg = Graphlib.create (module G) ~edges () inG161,5288
     let () = printf "Setting up initial solution \n%!" in()186,6632
     let first_node = match Seq.hd (Graphlib.reverse_postorder_traverse (module G) cfg) withG276,10039

edge_builder.ml,1445
open CoreEdge_builder1,0
module KB = Bap_knowledge.KnowledgeKB6,58
module Cfg = Bap.Std.Graphs.CfgCfg8,95
module IrCfg = Bap.Std.Graphs.IrIrCfg9,127
type edge = (Tid.t * Tid.t * bool)edge11,161
type edges = edge listedges13,197
type tidmap = Blk.elt Tid_map.ttidmap15,221
module Callees = structCallees17,254
  module S = Set.Make_binable_using_comparator(Sub)S18,278
module T = structT22,347
  type t = { tidmap : tidmap;t23,365
  type t = { tidmap : tidmap;tidmap23,365
             callees : Callees.t }callees24,395
module ST = structST28,445
let from_ : edge -> Tid.t = functionfrom_34,569
let to_ : edge -> Tid.t = functionto_37,648
let iter_insns sub : unit =iter_insns40,723
  let nodes = Graphlib.reverse_postorder_traverse (module Graphs.Ir) irg inGraphs45,920
  let last_node_insns = insns_of_node last_node inlast_node_insns161,4739
let edges_of_jump j sub nodes proj : edges ST.t =edges_of_jump165,4887
let edges_of_jump_intraproc j sub nodes proj : edges ST.t =edges_of_jump_intraproc218,7184
let get_jmp_edges insns sub nodes proj =get_jmp_edges250,8505
let edges_of_insns insns sub nodes proj : edges ST.t =edges_of_insns262,8878
let get_builder_for_sub sub proj : edges ST.t =get_builder_for_sub271,9291
  let nodes = Graphlib.reverse_postorder_traverse (module Graphs.Ir) irg inGraphs273,9369
let run_one (sub : Sub.t) (proj : Project.t) : (edges * tidmap) =run_one327,11219

interval_analysis.ml,1437
open CoreInterval_analysis1,0
module KB = Bap_knowledge.KnowledgeKB5,42
module IML = Map_lattice.IntervalIML6,78
module T = Bap_core_theory.TheoryT7,112
type result = Wrapping_interval.tresult9,147
type state = result IML.tstate11,182
let denote_binop (op : binop) : result -> result -> result =denote_binop14,242
  let open Wrapping_interval inopen16,332
let denote_cast (c : cast) : int -> result -> result =denote_cast38,822
  let open Wrapping_interval inopen39,877
let denote_unop (op : unop) : result -> result =denote_unop46,1023
let rec denote_exp (e : Bil.exp) (d : state) : result =denote_exp51,1178
     let () = Format.printf "TODO: support Bil.Concat\n%!" in()95,2701
let denote_def (d : def term) : state -> state =denote_def98,2791
let denote_phi (p : phi term) : state -> state =denote_phi105,3013
let denote_jmp (j : jmp term) : state -> state =denote_jmp110,3150
let denote_blk (b : blk term) : state -> state =denote_blk114,3223
let denote_node (n : Graphs.Ir.node) : state -> state =denote_node120,3399
let default_elt_value : result = Wrapping_interval.botdefault_elt_value125,3518
let setup_initial_state (sub : sub term) (irg : Graphs.Ir.t)setup_initial_state127,3574
  let nodes = Graphlib.reverse_postorder_traverse (module Graphs.Ir) irg inGraphs134,3844
let run (s : sub term) : (Graphs.Ir.node, state) Solution.t =run209,6680
    (module Graphs.Ir)Graphs231,7498

live_variables.ml,2008
open CoreLive_variables1,0
module T = Bap_core_theory.TheoryT119,6208
module NameAndTid = structNameAndTid121,6243
  module T = structT122,6270
    type t = string * Tid.t [@@deriving compare, sexp, equal, bin_io]t123,6290
  module Cmp = structCmp126,6367
  let make ~name ~tid : t = (name, tid)make134,6468
  module Set = structSet136,6509
module SS = Set.Make_binable_using_comparator(String)SS141,6593
let sub_to_ssa_sub : Sub.t -> Sub.t = Sub.ssasub_to_ssa_sub143,6648
let fold_over_elts (sub : Sub.t) ~(init : 'a) ~(f:'a -> Blk.elt -> 'a) ~(cong : 'a -> 'a -> 'a) fold_over_elts145,6695
module GetPhiAssnsPass = structGetPhiAssnsPass154,7055
  let elt_to_phi_var : Blk.elt -> NameAndTid.Set.t = functionelt_to_phi_var155,7087
  let run (sub : Sub.t) : NameAndTid.Set.t =run164,7428
module GetDefsPass : sigGetDefsPass172,7650
  type tt173,7675
  val def_tid_of_var_name : t -> string -> Tid.t optiondef_tid_of_var_name175,7685
  val run : Sub.t -> trun176,7741
  module M = Map.Make_plain_using_comparator(String)M178,7777
  type t = Tid.t M.tt180,7831
  let combine ~key which =combine182,7853
  let add_def_to_mapping mapping elt =add_def_to_mapping192,8110
  let def_tid_of_var_name (m : t) (name : string) : Tid.t option =def_tid_of_var_name206,8512
  let run (sub : Sub.t) : t =run215,8839
module IsUsedPass = structIsUsedPass231,9243
  module T = structT232,9270
    type t = { used : string;t237,9433
    type t = { used : string;used237,9433
               used_tid : Tid.t option;used_tid238,9463
               user_tid : Tid.t;user_tid239,9503
               user : string }user240,9536
  module UseRel = Set.Make(T)UseRel243,9623
  let phi_option_to_uses (_tid, opt_expr) : SS.t =phi_option_to_uses246,9679
  let elt_to_uses (e : Blk.elt) (defmap : GetDefsPass.t) : t list =elt_to_uses249,9767
type t = IsUsedPass.UseRel.tt320,12093
module Analysis = structAnalysis323,12187
  let run (sub : Sub.t) : t =run324,12212

map_lattice.ml,205
open CoreMap_lattice1,0
module KB = Bap_knowledge.Knowledge KB3,11
module Interval = structInterval11,263
  module K = StringK12,288
  module M = Map.Make_binable_using_comparator(String)M14,309

silent_store_checker.ml,121
open CoreSilent_store_checker1,0
let check_store _mem _idx _val _endian _size could_be_equal : bool =check_store5,53

silent_stores.ml,1337
open CoreSilent_stores1,0
module Checker(N : NumericDomain) = structChecker7,70
  module AI = AbstractInterpreter(N)(Abstract_memory.Region)(Abstract_memory.Region.Set)(struct AI16,306
  module AI = AbstractInterpreter(N)(Abstract_memory.Region)(Abstract_memory.Region.Set)(struct t16,306
  module I = Wrapping_intervalI18,438
  module Taint = Checker_taint.AnalysisTaint20,470
  module SS = Set.Make_binable_using_comparator(String)SS23,530
  type warns = Alert.Set.twarns25,589
  type t = warnst26,616
  let name = "silent-stores"name28,634
  module State = structState30,664
    type t = { warns: warns;t31,688
    type t = { warns: warns;warns31,688
               env: Env.t;env32,717
               tid : Tid.t;tid33,744
               liveness : Live_variables.t } liveness34,772
    let init in_state tid liveness =init36,819
  module ST = structST43,973
  let get_intvl : N.t -> Wrapping_interval.t =get_intvl49,1115
  let get_taint : N.t -> Taint.t =get_taint54,1333
  let is_tainted : N.t -> bool =is_tainted59,1524
  let dont_care_vars = ["ZF"; "OF"; "CF"; "AF"; "PF"; "SF"]dont_care_vars62,1603
  let empty : warns = Alert.Set.emptyempty65,1701
  let join : warns -> warns -> warns = Alert.Set.unionjoin66,1739
  let rec check_exp (e : Bil.exp) : N.t ST.t =check_exp73,1973

subroutine_getter.ml,238
open CoreSubroutine_getter1,0
module T = Bap_core_theory.TheoryT6,54
 module KB = Bap_knowledge.KnowledgeKB7,88
type name = stringname9,126
type addr = wordaddr10,145
type t = (name, addr) List.Assoc.tt12,163
let _ =_14,199

test_abstract_memory.ml,652
open CoreTest_abstract_memory1,0
module WI = Wrapping_intervalWI6,48
module T = Checker_taint.AnalysisT7,78
module ProdWIT = DomainProduct(WI)(T)ProdWIT8,112
module AM = Abstract_memoryAM10,151
module PtrWI = AM.Pointer(WI)PtrWI12,180
module Mem = AM.Make(WI)Mem13,210
module PtrWIT = AM.Pointer(ProdWIT)PtrWIT15,236
module MemWIT = AM.Make(ProdWIT)MemWIT16,272
let assert_wi_equal = OUnit2.assert_equal ~cmp:WI.equal ~printer:WI.to_stringassert_wi_equal18,306
let get_intvl : ProdWIT.t -> WI.t =get_intvl20,385
let get_taint : ProdWIT.t -> T.t =get_taint25,553
let suite = "Test_abstract_memory test suite" >:::suite157,5162

test_main.ml,98
open CoreTest_main1,0
let suites = [Test_wrapping_interval.suite;suites4,23
let () =()7,110

test_wrapping_interval.ml,1823
open CoreTest_wrapping_interval1,0
module WI = Wrapping_intervalWI5,36
let one = b1one9,90
let zero = b0zero10,103
let assert_equal = OUnit2.assert_equalassert_equal11,117
let i ?(width = 64) x = of_int_tuple ~width xi14,228
let test_add_basic _ = assert_equal (add one zero) onetest_add_basic17,293
let test_top_contains_one _ =test_top_contains_one19,349
let test_add_two_const _ =test_add_two_const23,468
let test_add_two_intvls _ =test_add_two_intvls26,530
let test_8_bit_wrap _ =test_8_bit_wrap33,720
let test_high_1_bitwidth_correct _ =test_high_1_bitwidth_correct40,903
let test_signed_result_small_intvl_correct _ =test_signed_result_small_intvl_correct47,1134
let test_unsigned_result_small_intvl_correct _ =test_unsigned_result_small_intvl_correct59,1535
let test_low_result_big_const_correct _ =test_low_result_big_const_correct71,1948
let test_high_result_small_const_correct _ =test_high_result_small_const_correct86,2378
let test_extract_middle_bits_correct _ =test_extract_middle_bits_correct101,2812
let test_concat_two_small_correct _ =test_concat_two_small_correct112,3117
let test_zero_contains_pow_two_false _ =test_zero_contains_pow_two_false125,3473
let test_256_contains_pow_two_true _ =test_256_contains_pow_two_true130,3629
let test_could_be_true_false _ =test_could_be_true_false135,3774
let test_could_be_true_true _ =test_could_be_true_true141,3911
let test_could_be_false_false _ =test_could_be_false_false146,4032
let test_could_be_false_true _ =test_could_be_false_true152,4170
let test_mul_two_consts_returns_expected_res _ =test_mul_two_consts_returns_expected_res157,4292
let test_mul_overflow_wraps_around_correctly _ =test_mul_overflow_wraps_around_correctly163,4455
let suite = "Test_wrapping_interval test suite" >:::suite179,4990

tid_map.ml,424
open CoreTid_map1,0
module M = Map.Make_binable_using_comparator(Tid)M5,42
let tid_of_elt = functiontid_of_elt8,103
let elt_same (e1 : Blk.elt) (e2 : Blk.elt) : bool =elt_same13,205
let add_insns insns tidmap =add_insns20,416
let t_of_sub_nodes nodes insns_of_node =t_of_sub_nodes26,559
let t_of_sub sub =t_of_sub33,721
  let nodes = Graphlib.reverse_postorder_traverse (module Graphs.Ir) irg inGraphs35,770

type_domain.ml,2541
open CoreType_domain1,0
module T = Bap_core_theory.TheoryT5,36
module KB = Bap_core_theory.KBKB6,70
module Key = Common.DomainKeyKey9,164
type t = CellType.tt11,195
let p = CellType.Ptrp12,215
let s = CellType.Scalars13,236
let u = CellType.Unknownu14,260
let n = CellType.Undefn15,285
let key : t Key.k = Key.create "type_domain"key17,309
let get : type a. a Key.k -> (t -> a) option = fun k ->get19,355
let set : type a. a Key.k -> t -> a -> t = fun k other replace ->set24,487
let bot = CellType.Undefbot29,620
let top = CellType.Unknowntop31,646
let make_top _sz _signed = topmake_top33,674
let b1 = CellType.Unknownb135,706
let b0 = CellType.Unknownb037,733
let order = CellType.orderorder39,760
let compare x y =compare41,788
let equal x y = 0 = compare x yequal49,903
let join x y = CellType.join x y |> Result.ok_exnjoin51,936
let meet x y =meet53,987
let contains x y =contains61,1218
let add x y =add65,1281
let sub x y =sub76,1582
let general_binop x y = sgeneral_binop87,1883
let mul = general_binopmul89,1910
let div = general_binopdiv91,1935
let sdiv = general_binopsdiv93,1960
let umod = general_binopumod95,1986
let smod = general_binopsmod97,2012
let lshift = general_binoplshift99,2038
let rshift = general_binoprshift101,2066
let arshift = general_binoparshift103,2094
let logand = general_binoplogand105,2123
let logor = general_binoplogor107,2151
let logxor = general_binoplogxor109,2178
let general_unop x = sgeneral_unop111,2206
let neg = general_unopneg113,2230
let lnot = general_unoplnot115,2254
let extract x hi lo = sextract117,2279
let concat = general_binopconcat119,2304
let booleq = general_binopbooleq121,2332
let boolneq = general_binopboolneq123,2360
let boollt = general_binopboollt125,2389
let boolle = general_binopboolle127,2417
let boolslt = general_binopboolslt129,2445
let boolsle = general_binopboolsle131,2474
let could_be_true _ = truecould_be_true133,2503
let could_be_false _ = truecould_be_false135,2531
let general_cast n x = sgeneral_cast137,2560
let unsigned = general_castunsigned139,2586
let signed = general_castsigned141,2615
let low = general_castlow143,2642
let high = general_casthigh145,2666
let to_string = functionto_string147,2691
let of_int ?width v = sof_int153,2847
let of_word w = sof_word155,2872
let of_z ?width z = sof_z157,2891
let bitwidth typ = failwith "can't bitwidth on type"bitwidth159,2914
let sexp_of_t = CellType.sexp_of_tsexp_of_t161,2968

uarch_checker.ml,562
open CoreUarch_checker1,0
module UarchCheckerExtension = structUarchCheckerExtension5,38
  let target_func_param = Extension.Configuration.parametertarget_func_param6,76
  let get_target_file_name (proj : Project.t) : string =get_target_file_name11,302
  let sub_matches_name target_name (sub : sub term) : bool =sub_matches_name17,535
  let get_target_func name proj =get_target_func20,642
  let pass ctxt proj =pass34,1118
  let register_pass ctxt =register_pass47,1636
let () = Extension.declare UarchCheckerExtension.register_pass()52,1718

var_name_collector.ml,160
open CoreVar_name_collector1,0
module SS = Set.Make_binable_using_comparator(String)SS4,24
type t = SS.tt6,79
let rec run (e : Bil.exp) : SS.t =run8,94

wrapping_interval.ml,1135
open CoreWrapping_interval1,0
module T = Bap_core_theory.TheoryT4,24
module KB = Bap_core_theory.KBKB5,58
let package = "uarch-checker"package7,90
let name = "interval"name8,120
let desc = "Interval type/domain for abstract interpretation"desc9,142
let width = 128 (* bits *)width10,204
type range = {lo: Z.t; hi: Z.t; width: int; signed: bool} (* [@@deriving bin_io] *)range12,232
type range = {lo: Z.t; hi: Z.t; width: int; signed: bool} (* [@@deriving bin_io] *)lo12,232
type range = {lo: Z.t; hi: Z.t; width: int; signed: bool} (* [@@deriving bin_io] *)hi12,232
type range = {lo: Z.t; hi: Z.t; width: int; signed: bool} (* [@@deriving bin_io] *)width12,232
type range = {lo: Z.t; hi: Z.t; width: int; signed: bool} (* [@@deriving bin_io] *)signed12,232
type t = Bot | Interval of range (* [@@deriving bin_io] *)t13,316
type t = Bot | Interval of range (* [@@deriving bin_io] *)Bot13,316
type t = Bot | Interval of range (* [@@deriving bin_io] *)Interval13,316
let empty = Botempty16,418
let bot = Botbot17,434
let make_b1 width signed = Interval {lo=Z.one; hi=Z.one; width; signed}make_b119,449

/Users/mkf727/repos/bap,include

/Users/mkf727/.opam/bap-alpha/lib/zarith,include

/Users/mkf727/.opam/bap-alpha/lib/core,include
